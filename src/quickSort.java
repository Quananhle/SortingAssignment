import java.util.ArrayList;
import java.util.Random;

/**
 * The quickSort class is is used to implement a Quick Sorting process on an Array of random integers that are 
 * automatically generated by the algorithm, the class can be used to either animate the bubble sort process or
 * record the time taken to fully sort a single array. Runs as a single thread.
 * @author Oliver Palmer, stuNumber 12089466
 *
 */
public class quickSort implements Runnable {

	static Random r = new Random();
	static final int largestValue = 100;
	drawPanel draw;
	private int Array[];
	boolean running = false, animate = true;
	ArrayList<arrayStore> list;

	/**
	 * Constructor for quickSort
	 * @param i int, determine the size of the array to be sorted
	 * @param d drawPanel, the JPanel that the animation is draw on
	 * @param animate boolean, to determine whether the class is being accessed for animation or analysis
	 * @param l ArrayList, used to store the sort time and array size when performing analysis
	 */
	quickSort (int i, drawPanel d, boolean animate, ArrayList<arrayStore> l){
		Array = new int[i];
		draw = d;
		this.animate = animate;
		this.list = l;
	}

	/**
	 * Sort method, used to begin the sorting progress, records the time in nano seconds then divides by 1000 to convert
	 * the value to microseconds. If the class is initialised to analyse the data then this method records the timetaken and
	 * array size in the array list provided by the constructor
	 */
	public void sort(){

		running = true;
		fillArray(Array);

		long startTime = System.nanoTime();
		QuickSort(Array, 0, Array.length - 1);
		long endTime = System.nanoTime();

		long timeTaken = (endTime - startTime) / 1000;

		if (animate == false) {
			this.list.add(new arrayStore(Array.length, timeTaken));
		}
		running = false;
	}

	/**
	 * QuickSort method, calls partition method that returns the middle index for the array then recursively calls itself
	 * to perform a QuickSort on the left portion of the array and the right portion until the array is reduced to one item
	 * @param a integer Array, the array to be sorted
	 * @param left, the left most index of the portion of the array to be sorted
	 * @param right, the right most index of the portion of the array to be sorted
	 */
	private void QuickSort(int[] a, int left, int right){

		int index = partition(a, left, right);

		if (running == true) {
			if (left < index - 1){
				QuickSort(a, left, index - 1);
			}
		}
		if (running == true) {
			if (index < right){
				QuickSort(a, index, right);
			}
		}
	}

	/**
	 * partition method, uses the left and right values passed in to find the middle index between those two points, uses the value 
	 * of this index as a pivot point, sorts the array by moving all the values that are smaller than the pivot to the left side of 
	 * the pivot and all the larger values to the right of the pivot, returns the middle index of the array relative to the left and
	 * right indexes
	 * @param a integer Array, the array to be sorted
	 * @param left, the left most index of the portion of the array to be sorted
	 * @param right, the right most index of the portion of the array to be sorted
	 * @return i, the middle index relative to the left and right values passed in
	 */
	private int partition(int[] a, int left, int right){

		int i = left;
		int j = right;
		int pivot = a[(left + right) / 2];

		while (i <= j){
			while (a[i] < pivot){
				i++;
			}
			while (a[j] > pivot){
				j--;
			}
			if (i <= j) {

				swap(a, i, j);
				i++;
				j--;
			}
		}
		return i;
	}

	/**
	 * Swap method used to swap two values in the array
	 * @param a the array containing the values to be swapped
	 * @param i the index of one of the values to be swapped
	 * @param j the index of the other value to be swapped
	 */
	private void swap(int[] a, int i, int j){
		int temp = a[i];
		a[i] = a[j];
		a[j] = temp;
		// if required to animate, sends current state of array to drawPanel
		if (animate == true ) {
			draw.draw(a);
			// sleep statement required to make the animation run at a visible speed
			try{ Thread.sleep(10); }  catch (InterruptedException e) {}
		}
	}

	/**
	 * fillArray method fills the classes array with random numbers ranging from 0 to 100
	 * @param a the array to fill
	 */
	private static void fillArray (int[] a){
		for (int i = 0; i < a.length; i++){
			a[i] = r.nextInt(largestValue);
		}
	}

	/**
	 * Stop method, changes the boolean value running to false so the code will halt when the value is next checked
	 */
	public void stop() {
		running = false;
	}

	/**
	 * run method, used for running the class as a thread
	 */
	@Override
	public void run() {
		sort();
	}
}
